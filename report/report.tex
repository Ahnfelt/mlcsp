\documentclass[11pt,oneside,a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fncylab}

\newcommand{\missing}[1]{
\begin{tabular}{|p{11cm}|}
\hline
\emph{Missing:} {\scriptsize (things that need to be written or considered)} \\
\hline
#1
\hline
\end{tabular}
}

\begin{document}

\section{Channels}
\missing{
This section is a short introduction to channels \\
- Explanation for people who don't know CSP \\
- Possibly a figure with boxes and lines as a metaphor for processes and channels \\
}

\subsection{Communication}
\missing{
This section describes the communication primitives \\
- Synchronization (might be the trickiest part to get right) \\
- Read, Write, Poision \\
}

\begin{figure}[h]
\centering
\begin{tabular}{l|l|l}
CSP & OCamlCSP (short) & OCamlCSP (long) \\
\hline
$c\,?\,x \to x$ & read c & let x = read c in x \\
$c\,!\,x \to skip$ & write c x & write c x; () \\
(no equivalent) & poison c & poison c; () \\
\end{tabular}
\caption{Channels in CSP vs. OCamlCSP}
\label{channel-communication}
\end{figure}

\subsection{Alternation}
\missing{
This might be it's own section or be merged with communication \\
- Alternation (and read/write/timeout guards) \\
- Communication scheduling (prioritized/random select) \\
- More synchronization \\
- Actions are automatically performed when chosen (no promises) \\
- Does random (prioritized (shuffle list)) mean fair? \\
- Consider having a ``poll'' function that does nothing if none of the alternatives are ready \\
}

\begin{figure}[h]
\centering
\begin{tabular}{l|l}
CSP & OCamlCSP \\
\hline
& \\
($c_1\,?\,x \to x \mid c_2\,?\,y \to y$) & random [ \\
& \quad Read (c1, fun x $\to$ x); \\
& \quad Read (c2, fun y $\to$ y) ] \\
& \\
($c_1\,?\,x \to x \mid c_2\,!\,a+b \to a+b$) & random [ \\
& \quad Read (c1, fun x $\to$ x); \\
& \quad Write (c2, (fun () $\to$ a + b), fun v $\to$ v) ] \\
& \\
(no equivalent) & random [ \\
& \quad Read (c1, fun x $\to$ x); \\
& \quad Wait (0.100, fun t $\to$ 0) ] \\
\end{tabular}
\caption{Alternation in CSP vs. OCamlCSP}
\label{channel-alternation}
\end{figure}

\subsection{Capabilities}
\missing{
This section describes the channels ``end'' capabilities \\
- Phantom types (with polymorphic variants, informal: channel ends) \\
- Capabilities can only be taken away, not added \\
- All (useful) capability combinations are covered \\
}

\begin{figure}[h]
\centering
\begin{tabular}{c|c|c|l}
`Read & `Write & `Poison & Function \\
\hline
0 & 0 & 0 & (useless) \\
0 & 0 & 1 & poison\_only \\
0 & 1 & 0 & write\_only \\
0 & 1 & 1 & write\_poison\_only \\
1 & 0 & 0 & read\_only \\
1 & 0 & 1 & read\_poison\_only \\
1 & 1 & 0 & read\_write\_only \\
1 & 1 & 1 & (default) \\
\end{tabular}
\caption{Channel end capabilities}
\label{channel-capabilities}
\end{figure}

\section{Processes}
\missing{
This secion describes the process primitives \\
- Lambda functions (closures that capture channels) \\
- Joining \\
- Captures the return values (functional, not for fork) \\
- Exception propagation (when all processes are done, not for fork) \\
- Scope differences from CSP? \\
- Find out if spawn has an equivalent in CSP. \\
}

\begin{figure}[h]
\centering
\begin{tabular}{l|l}
CSP & OCamlCSP \\
\hline
& \\
($c_1\,?\,x \to skip \parallel c_2\,?\,y \to skip$); $c_3\,!\,x + y$ & let (x, y) = parallel \\
& \quad (fun () $\to$ read c1) \\
& \quad (fun () $\to$ read c2) \\
& in write c3 (x + y) \\
& \\
(imperative representation) & let x = ref 0 in \\
& let y = ref 0 in \\
& fork [ \\
& \quad (fun () $\to$ x := read c1); \\
& \quad (fun () $\to$ y := read c2) ]; \\
& write c3 (!x + !y) \\
& \\
(no equivalent) & spawn 10 (fun i $\to$ \dots) \\
\end{tabular}
\caption{Parallel processes in CSP vs. OCamlCSP}
\label{channel-parallel}
\end{figure}

\end{document}
