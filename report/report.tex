\documentclass[a4paper,12pt]{article}
%\usepackage{fullpage}
%\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[danish, english]{babel}

% Nice looking font
%\usepackage{palatino}

% In order to highlight code
\usepackage[pdftex]{color}
\usepackage{listings}

% For graphics support
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{subfigure}

% Math support
\usepackage{amsmath}

% In order to include pdf
\usepackage{pdfpages}

% Graf support
\usepackage{tkz-graph}

% Pdf section support
\usepackage{hyperref}
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat's bookmarks
    pdftoolbar=false,       % show Acrobat's toolbar?
    pdfmenubar=false,       % show Acrobat's menu?
    pdffitwindow=true,      % page fit to window when opened
    pdftitle={OCamlCSP. A concurrency library for Ocaml}, % title
    pdfauthor={Joakim Ahnfelt-Rønne - 1986/03/14 - joakim.ahnfelt@gmail.com,
        Ramón Salvador Soto Mathiesen - 1979/05/15 - ramon@diku.dk and
        Advisor: Andrzej Filinski - andrzej@diku.dk}, % author
    pdfsubject={},   % subject of the document
    pdfnewwindow=true,      % links in new window
    pdfkeywords={keywords}, % list of keywords
    colorlinks=false,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

% Macros
\newcommand{\missing}[1]{
  \begin{tabular}{|p{11cm}|}
    \hline
    \emph{Missing:} {\scriptsize (things that need to be written or considered)} \\
    \hline
    #1
    \hline
  \end{tabular}
}

\newcommand{\runtest}[1]{
  \footnotesize
  \framebox[14.5cm][l]{#1}
  \normalsize
}

\newcommand{\includecode}[2]{
  \definecolor{stringcolor}{rgb}{0.50,0.00,0.50}      %
  \definecolor{commentcolor}{rgb}{0.00,0.50,0.00}     %
  \definecolor{keywordcolor}{rgb}{0.00,0.00,1.00}     %
  \definecolor{idcolor}{rgb}{0.00,0.00,0.00}          %
  \lstset{language=ML,basicstyle=\ttfamily,keywordstyle=\color{keywordcolor},
    commentstyle={\color{commentcolor}\itshape},
    stringstyle={\color{stringcolor}},
    identifierstyle=\color{idcolor},numbers=left,
    xleftmargin=2em,% framerule=0.8pt,
    stepnumber=1,frame=tlrb,showstringspaces=false,
    firstnumber=1,numberstyle=\ttfamily, breaklines}

  \normalsize
  #1:
  \scriptsize
  \lstinputlisting{#2}
  \normalsize
}

\newcommand{\includeoutput}[2]{
\definecolor{allblackcolor}{rgb}{0.00,0.00,0.00}      %
\lstset{basicstyle=\ttfamily,keywordstyle=\color{allblackcolor},
        commentstyle={\color{allblackcolor}\itshape},
        stringstyle={\color{allblackcolor}},
        identifierstyle=\color{allblackcolor},numbers=left,
        xleftmargin=2em,% framerule=0.8pt,
        stepnumber=0,frame=tlrb,showstringspaces=false,
        firstnumber=1,numberstyle=\ttfamily, breaklines}

  \normalsize
  #1:
  \scriptsize
  \lstinputlisting{#2}
  \normalsize
}

% Opening
\title{OCamlCSP - a concurrency library for Ocaml}
\author{Joakim Ahnfelt-Rønne - 1986/03/14 - joakim.ahnfelt@gmail.com \and 
        Ramón Salvador Soto Mathiesen - 1979/05/15 - ramon@diku.dk \and
        \\ Advisor: Andrzej Filinski - andrzej@diku.dk}
\date{31$^{st}$ July 2009}

\begin{document}

\maketitle

\newpage
\selectlanguage{danish}
\begin{abstract}
% Grue: Højest 10 linjer: Hvad handler rapporten om? Hvilke resultater er
% opnået?
Her på dansk
\end{abstract}

\newpage
\selectlanguage{english}
\begin{abstract}
Here in english
\end{abstract}

\newpage
\tableofcontents
\newpage

% Line breaks between paragraphs instead of indentation
\parindent=0pt
\parskip=8pt plus 2pt minus 4pt

\section{Introduction}
This project is a complete, designed and implemented, API for a CSP-based
concurrency library in a functional language, in this case Ocaml\cite{?}.

We have achieved our three primary goals we set at the beginning:
\begin{itemize}
 \item \textbf{Designing an API for a CSP-based concurrency library in a
     functional language}. Because our main focus was on the API design, most of
   the {\it Section} \ref{analysis} is related to this.
 \item \textbf{Implementing the concurrency API in a functional language.} A
   complete description on how we implemendted the API based on the limitations
   of the chosen language?, use of a global lock. For more information look in
   the {\it Section} \ref{implementation}.
 \item \textbf{Assessing the API and underlying implementation by comparing
     applications built on top of it with similar applications built on top of
     an existing CSP library}. We have made a simple CSP network, Fibonacci,
   and a more complex, Webproxy, in order to test the API. The application are
   similar to the applications we have made for one of the other CSP libraries.
   A full description on how these applications are build and how to compile-run
   can be seen in the {\it Section} \ref{test}.
\end{itemize}

The resulting API source code and documentation can be seen in the Appendix
\ref{appendixSrc} and \ref{appendixDoc}. A online version is also avaliable at:

\begin{center}
http://github.com/Ahnfelt/mlcsp/
\end{center}

About the possible extensions to this API, we got wise on that we cannot
implement true parallelism through system threads, see at {\it Section
\ref{analysis}} for more information, but how we ``maybe'' can implement
parallelism with distribution through sockets, see {\it Section 
\ref{conclusion}}.

\section{API design}
\label{analysis}
\missing{
- What do we do about shared state?\\
- Compare with the Event library.\\
- More introduction.\\
- Mention that we don't use OCaml's object model.\\
- Compare more with Occam.\\
- Mention that channels are typed.\\
}

The CSP theory is concerned with processes that communicate solely by synchronous 
events. Synchronous channels are built on top of the basic abstraction, and this is
what most implementations (including \cite{occam}, \cite{c++csp}, \cite{jcsp} and 
\cite{pycsp}) provide for communication. 
Additionally, it is possible to wait for communication from multiple sources at once.

For each construct, we are going to look at how it's done in CSP and in the 
existing CSP libraries, how we would like to write it in OCaml, and what the 
semantics should be. We will use the explicit module prefix \verb|Csp.| in front
of any functions that come from our API.

\subsection{Processes}
\missing{
- More about the lack of parallelism.\\
}

Processes can be run in parallel in CSP using the $\parallel$ operator:
\[P \parallel Q\]
The semantics of this is that the two processes $P$ and $Q$ are run in parallel. They
may communicate with each other. If put in front of another process in a sequence, all
processes running in parallel must finish before the next process can take any steps.

In PyCSP running two processes in parallel looks like this:
\begin{verbatim}
Parallel(P, Q)
\end{verbatim}
Where $P$ and $Q$ must be specified as $Process$ instances. There may be more processes
separated by commas. It runs the processes in parallel and returns when they have all 
stopped executing. Since Python does not offer a literal syntax for such objects that can 
be used in a expression, the processes must be defined elsewhere. The API for C++CSP and 
JCSP are similar, although Java does offer object literals. In all cases the object 
literals only expose a \emph{run} method. It is unclear what happens if this method is 
called twice on the same instance (especially if the instance is used twice in the same 
parallel-construct).

To avoid that kind of undefined behaviour we do not provide handles to 
\emph{running processes}.
A process is simply any OCaml expression, although we use functions to delay the 
evaluation of them until their side effects are desireable. 
Our parallel construct looks like this:

\begin{verbatim}
Csp.parallel [
    (fun () -> ...);
    (fun () -> ...);
]
\end{verbatim}

We use a list so it is possible to specify any number of processes. The 
\verb|(fun ...)|s may be any OCaml expression, although we require that they are of type
$unit \to unit$. Since OCaml has anonymous functions, we can define the process directly 
inside the parallel construct, which is often convenient for small processes. The processes
are then run in parallel, and there is no way to get a handle to a running process
through our API.

Sometimes it is useful to define a function that starts a process as a side effect, but
returns before the process has finished. This corresponds to running the process in 
parallel with \emph{the rest of the program}. Since we don't have continuations, we 
provide the special purpose function \emph{fork} that simply starts a process and returns
immediatly. JCSP does something similar with their \emph{ProcessManager}, but provides a
\emph{stop} method that will terminate the process. It has since been deprecated because
it is unsafe to terminate a running process from the outside. There is not much else to 
do with such a handle, so we avoid returning one at all.

We don't provide a special construct for sequence, since OCaml has a perfectly fine 
sequence operator built in, and executing a list of processes in sequence is a simple
matter of iterating over it and invoking each one. We also don't provide a way to specify 
the stack size for a process, because the stack grows dynamically in OCaml user threads, 
and there is little reason to use system threads (see section \ref{implementation}).

Note that the library \emph{does not provide parallel execution}; it only provides 
perceived concurrency (see section \ref{implementation}).

\subsection{Channels}

As in CSP, channels are the only means of communication between processes that we provide.
In PyCSP, C++CSP and JCSP, channels are created by constructing an instance of a channel
class. Our channels correspond to their \emph{any2any} channels, meaning that any number
of processes can send on and receive from a channel. However, any any message has exactly 
one sender and one receiver, and communication is synchronous.

Creating a channel is just a call to a function which returns the new channel:
\begin{verbatim}
let c = Csp.channel ()
\end{verbatim}

Two of the basic constructs for CSP channels are send and receive:
\[c\,!\,e \to ...\]
\[c\,?\,x \to ...\]
Where $c$ is a channel, $e$ is an expression, $x$ is a name and the $...$s are processes. 
The semantics of these are to synchronously send or receive a value respectively, and
then become another process. In the case of receive, the process may refer to the
received value by the name $x$.

In PyCSP, these two constructs look like this:
\begin{verbatim}
c.write(e)
...
\end{verbatim}
\begin{verbatim}
x = c.read()
...
\end{verbatim}
It's using methods to realize the read/write, and sequence to realize \emph{becoming}
another process after the synchronization. Note that the channels are values, whereas
they are names in CSP. JCSP and C++CSP are similar.

The obvious way to look like CSP is to define operators ! and ? that works like the
CSP counterpart. However, it is not possible in OCaml to declare that the right hand 
side of the question mark introduces a binding. It is also not desireable to redefine
the ! operator that is used for dereferencing mutable references in OCaml.

We therefore have to decide between methods and functions. The OCaml standard library
primarily uses functions to provide it's functionality, and few if any other ML 
variants share OCaml's object model. Since we don't anticipate any need for an
exstensible inheritance hierachy for channels, we choose functions for the task.
We use the \textbf{let in} construct to provide binding.

\begin{verbatim}
Csp.write c e; ...
\end{verbatim}
\begin{verbatim}
let x = Csp.read c in ...
\end{verbatim}

It is possible to transmit any OCaml value over a channel, including impure functions and mutable 
state. Sharing mutable state between processes should only be done with caution however, since it 
requires additional synchronization beyond the scope of this library. The remaining semantic 
details of the channels are explained in the following section.

\subsection{Alternation}
\missing{
- PriSelect (not there because it's not well defined).\\
- FairSelect (what problem does this actually solve?).\\
- Polling or skip guards (can be implemented as a process). \\
- Time guards (can be implemented as a process). \\
}

Alternation corresponds to \emph{external choice} in CSP, which uses the $|$ operator:
\[c_1\,?\,x \to ...\ |\ c_2\,?\,y \to ...\ |\ c_3\,!\,e \to ...\]
The operands of the operator are arbitrary processes. The semantics is that once one or 
more of the alternatives can take a step, then an arbitrary one of these is chosen to take a 
step, and then the whole process acts as the remainder of the chosen alternative.

In PyCSP it looks like (where in1 = c1.read, in2 = c2.read, out3 = c3.write):
\begin{verbatim}
s = Alternative(in1, in2, out3).priSelect()
if s == in1:
    x = in1()
    ...
elif s == in2:
    y = in2()
    ...
else:
    out3(e)
    ...
\end{verbatim}
Here $s$ becomes one of $in1$, $in2$ and $out3$, which are \emph{channel ends}. These are instances
of ordinary classes that define a special method that allows for the call-like syntax above.
The JCSP and C++CSP selects take in a list of guards and return the index of the guard, which you can 
then switch on. In both cases, you have to \emph{promise} to read from the chosen channel, or the 
behaviour will be undefined.

Starting from CSP's syntax, we might want to write something like \texttt{(A | B | C)}, where $A$, $B$
and $C$ are processes. One might define an operator $|$ that takes two processes and returns the result 
of the one that is chosen. The problem with this is that it is very hard in plain OCaml to inspect 
functions at runtime to see which one of them can take a step.

The existing libraries solve this by providing \emph{guards}, which exposes the first action as a value 
that can easily be inspected by the library. After a guard is selected, the action it specifies must be 
carried out, and it is the programmer's responsibility to ensure this. In the case of PyCSP, channel
ends are also read- or write guards. 

Placing the responsibility on the programmer will lead to bugs if the programmer fails to obey the 
requirements. To avoid this, we instead provide \emph{guarded processes}, which combine the guard and
the corresponding actions. Each possible first action has it's own constructor, and is automatically 
carried out when the guard is chosen. We use a list instead of an operator in order to provide a more 
natural syntax for alternation between more than two guarded processes.

Our alternation construct is intended to capture the conditional logic which typically follows 
alternation in the existing CSP libraries.

\begin{verbatim}
Csp.select [
    Csp.read_guard c1 (fun x -> ...);
    Csp.read_guard c2 (fun y -> ...);
    Csp.write_guard c3 e (fun () -> ...);
]
\end{verbatim}

Whereas external choice in CSP is between processes, our alternation is between guarded processes.
The \verb|(fun ...)|s can be any OCaml expression. The read guards require that the expression is of type
$\alpha \to \beta$ where $\alpha$ is the type of messages that can be sent over the guard's channel, whereas
for the write guards it must be of type $unit \to \beta$. The $\beta$ types must be the same for all guards in 
a list. It will return the result of evaluating the chosen guarded process.

In CSP, any process that can take a step may be chosen arbitrarily. However, if the same list of 
alternatives is used in a loop, this might lead to starvation. If one of the guards is always ready,
an arbitrary choice can be to chose this one every time. This means that any other guards that are 
ready will be skipped indefinatly, and thus be starved.

We solve this by prioritizing the guards in a random order each time select is called. That way the
chance that a ready guard is not taken approaches zero as the number of calls to select grows.

If multiple processes repeatily wait to act on the same channel, and one process is chosen every time,
the other processes will be starved. We solve this by serving processes wating on any given channel
on a first come, first served basis.

Note that this is also a valid behaviour of the arbitrary choice, which we don't provide separatly.

The \emph{read} and \emph{write} functions are semantically equivalent to a select that has exactly 
one guard.

The semantics of the select so far is to block until one of the guards become ready. The obvious
way to define a select with no guards at all is therefore to block indefinatly, causing a deadlock.
Preferably, the thread would not take up any further resources in this case (since it's trivial to 
detect), and thus we attempt to terminate the thread by throwing an exception. If stack traces are
enabled, and the empty select is an error, this might also provide the programmer with more information
to determine where the error occured.

We do not provide any API for internal choice, since OCaml has plenty of control structures built-in.
In JCSP and C++CSP you can provide a list of flags that specify if a guard is active or inactive. We
do not provide this as it is just as easy to simply filter the list of guards.

\subsection{Termination of process networks}
\missing{
- Automatic poison propagation (PyCSP has it by relflection)\\
- Why have a function to check if a channel is poisoned (it's almost useless)?\\
- What about common design patterns for propagate poison?\\
}

Since no practical applications run forever, termination of process networks should be considered.
Interruption of the process from an external source is an obvious but poor choice, since it does not
allow the process to clean up and propagate the termination to it's subprocesses.

Another way to implement this is to send a special termination message. However, that requires 
insertion of termination logic for every communication where the process might receive a termination 
message. Additionally, if the readers want to terminate the writers of a channel, it will often 
require a dedicated channel just for termination messages.

If there are multiple processes that listen on a channel, it would also be hard to ensure that they had
all received the termination message before the process sending it shuts down. To keep track of this you
might need to know the number of processes that are listening or are going to listen on the channel, 
which might not even be possible to determine. The process that wants to send the terminating process 
could loop forever, repeating the termination message to anybody who read from the channel, but then 
that process could never shut down.

In PyCSP, JCSP and C++CSP, a channel may be \emph{poisoned}. Once a channel
has been poisoned, reading from or writing to that channel causes an exception.
The exception may be handled, thus allowing the process to clean up, propagate
the poison, or even ignore the poisoning. That way, the process remains in
control of it's own lifespan. A channel that has been poisoned can never become
unpoisoned. We provide the same construct:

\begin{verbatim}
Csp.poison c 
\end{verbatim}

Read and write guards become ready if their channel is poisoned, and an
alternation may thus chose to throw a PoisonException if one or more of it's
guards' channels are poisoned.

In order to shut down process networks, which may have intrnal subnetworks, it
is nessecary to propagate the poison to the other processes in the network. As
mentioned, this can be done in the handler for PoisonException. PyCSP
automatically poisons channels that are arguments to process constructors. In 
many cases this is the desired behaviour. JCSP and C++CSP do not provide it, and
neither do we due to technical issues (see section \ref{implementation}).

\subsection{Permissions}

PyCSP, JCSP and C++CSP provide a concept called \emph{channel ends}, which are handles to channels
though which you can only read or only write (or some other set of permissions). This is useful for
specifying what a process might do with a channel, so unintended use of a channel can be caught
early.

We provide this through a set of functions, each of which takes a channel returns a handle with only
a specific set of permissions:

\begin{verbatim}
let i = Csp.read_only c
\end{verbatim}

It is a compile time error to attempt to write to or poison the returned handle. The permissions are 
provided purely through the type system, and none of the functions can add permissions. 
See secion \ref{implementation} for the complete set.

\section{Implementation}
\missing{
- Mention that we do everything within OCaml's type system.\\
- Mention why we can't have parallelism.\\
- Mention why it isn't interesting to use system threads.\\
- Describe why we cannot provide automatic poison propagation.\\
}
\label{implementation}


\subsection{Channels}
A one to one channel is a channel that only allows one procees to read from it and one process 
to write to it. It may be implemented as a state machine as shown in figure \ref{channel-state}.
When the channel is in the NobodyWaiting state and a process tries to read from the channel,
it enters the ReaderWaiting state. When a writer comes along and tries to write to a channel
in this state, it returns to the NobodyWaiting state, transfers the message, and only then
allows the two processes to continue. The WriterWaiting state works in much the same way.

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{channel-state.png}
\caption{Simplified channel state (poison and multi-read/write not shown)}
\label{channel-state}
\end{figure}

From any state, the channel might be poisoned and enter the Poisoned state. If it was in the
ReaderWaiting or the WriterWaiting state, the waiting process will wake up and throw a special
exception. Any further attempts to read from or write to the channel will result in this 
exception being thrown again.

For any to any channels that places no restrictions on the number of processes that can read
from or write to it, we simply extend the above to keep a queue of readers (when in the 
ReaderWaiting state) or writers (when in the WriterWaiting state).

The choice of using a queue gives a stronger guarentee than CSP gives, namely that no processes
will be starved. By starvation we mean to say that a process waiting to read or write on the
channel can be blocked indefinately even though an infinite number of messages is transmitted
over the channel. This would happen with a stack if another process is always ready to read or 
write again before the channel was ready to accomodate the starving process. The starving process
would always be put behind the eager process with a stack, but with a queue, the starving process
will always advance in the queue every time a message is transmitted, guarenteeing that it will
eventually get it's turn.

In order to only wake up the waiting process, each process has it's own condition variable that
it waits on. Additionally, readers have a function that takes in a value and performs a side 
effect, while writers have a function that performs a side effect and produces a value. The side
effect for both is to set it's internal reference to the transmitted value (instead of None),
remove it from all the channels it's listening on and wake up the process.

We use a lock that is global to the library, in order to protect the channel and processes from
concurrent mutation. This lock is only taken when first trying to read from a channel, or
right after a process has been woken up. We claim that this won't lead to performance degradation,
since OCaml's threads only provides concurrency though time-sharing \cite{ocaml-threads}.

\missing{
- How do you get rid of this lock? (useful for porting). It is hard because you don't know which
channels you will touch before you have chosen a target process to transmit to/from. If you knew
that, you could simply take their locks in some well defined order (thus avoiding deadlock). \\
}

\begin{verbatim}
type 'a channel_state
    = NobodyWaiting 
    | ReaderWaiting of (Condition.t * ('a -> unit)) list
    | WriterWaiting of (Condition.t * (unit -> 'a)) list
    | Poisoned

type ('a, 'b) channel = ('a channel_state) ref
\end{verbatim}

The phantom type 'b is used for the channel permissions. This is enforced solely via the type
system, and is represented with a product of three booleans values: read * write * poison.
Reading, writing and poisoning are initially enabled for a channel, but handles with less 
permissions can be obtained through the functions shown in figure \ref{channel-permissions}. 
Permissions can only be taken away, not gained, which is evident from the types of the 
functions, for example: 

\begin{verbatim}
val read_poison_only : ('a, on * _ * on) channel -> 
                       ('a, on * off * on) channel
\end{verbatim}

Apart from the type, all of these functions are simply identity functions. We provide a
type alias \texttt{'a t = ('a, on * on * on) channel} for people who don't want to write the
longer (often optional) type annotations that the permission types incur.

\begin{figure}[h]
\centering
\begin{tabular}{c|c|c|l}
Read & Write & Poison & Function \\
\hline
0 & 0 & 0 & (useless) \\
0 & 0 & 1 & poison\_only \\
0 & 1 & 0 & write\_only \\
0 & 1 & 1 & write\_poison\_only \\
1 & 0 & 0 & read\_only \\
1 & 0 & 1 & read\_poison\_only \\
1 & 1 & 0 & read\_write\_only \\
1 & 1 & 1 & (default) \\
\end{tabular}
\caption{Channel permissions}
\label{channel-permissions}
\end{figure}

\subsection{Alternation}

\missing{
- Occam does not seem to sufficiently describe PRI ALT when two processes with inverse priorities
on the same two channels use it (in the manual). This is why we don't support it. \\
- Consider supporting something a bit like PRI ALT anyway since it's easier to build on top of
than the current randomized select. \\
}

\subsection{Processes}

\section{Test}
\label{test}
One of the goals for this project was that we needed to implement a simple
network on top of the API, Fibonacci, and a more complex network, The Ising 2D
Model.

Because Ocaml doesn't have support for parallelism, as mentioned in the Analysis
Section\ref{?}, we decided to make a Webproxy, with a build in cache.

But before we made this two applications we needed to now the limitations of
Ocamls Thread library and IO Library.

A detailed description on how to run the test can be seen in
Appendix \ref{appendixTest}.

\subsection{Performance}

%\begin{table}[ht]
%\centering
\begin{tabular}{|p{3cm}|p{8.5cm}|c|}
    \hline
    	File name &
	Description &
	Result \\
    \hline
    	maxthreads.ml (user thread) &
        The application creates as many threads as possible, once it reaches
        about 15.000 it stops spawning more threads (deadlock ?).&
	FAIL \\
    \hline
    	maxthreads.ml (system thread) &
        The application creates as many threads as possible, once it reaches
        about 100 it stops spawning more threads (deadlock ?).&
	FAIL \\
    \hline
    	nonblocking.ml &
        We run to processes in parallel. The first process whats for user input
        and the second process after a seconds delay reads the first line from
        the its own source code file and writes the line to stdout.&
	OK \\
    \hline
    	commstime.ml &
        A benchmark application used by Brian Vinter to measure PyCSP vs JCSP.&
	OK \\
    \hline
  \end{tabular} 
%\caption{The first three test checks Ocaml implementation of the Thread library
%  and I/O. In the last test, we compare OcamlCSP vs PyCSP.}
%\label{testtable}
%\end{table}

\subsubsection*{Maxthreads}
In this test we try to find an upperbound of how many threads we can create,
user threads or system threads. In the first case when using user threads we
find that after creating between 15.000 - 20.000 threads the application
freezes. We are not able to find any kind of documentation that can helps us
verify that it's a deadlock or a maximum number of threads allowed for an
application to create. If we run the test several times, we will see that
each application will be able to create about those 15.000 - 20.000 threads.

In case it's a limitation in Ocaml, we could by implementing sockets always
start $n$ times the application and make them comunicate over sockets so we
could achieve the number of threads as we desire.

In the second test based on maxthreads, we use system threads and as before
the application freezes but just after creating about 100 threads.


\subsubsection*{Nonblocking}
To implement the Webproxy we need to know if one of the processes is waiting
to recieve a chunck of data, if it block the IO until it has recieved the data
or if another process that is also waiting for a chunck.

We discovered that Ocaml support non-blocking IO so it will be no problem have
several clients waiting to recieve data from our Webproxy. An example could
be a client that connects over the Webproxy to a very slow website. The website
can only deliver a small amount of data every second. If another client that
also connects over the Webproxy to a fast website. While the first client
waits to recieve data from the webserver, the second client can read chunks
of data from the fast website.


\subsubsection*{Commstime}
Even though we don't set focus on performance and optimization, we still wanted
to implement the Commstime\cite{vinterpycsp} process that's used to compare
PyCSP against JCSP.

The only change we made to the code is that we use {\it Unix.gettimeofday} in
order to get the same time precision as Pythons {\it time.time} has. By running
both application on the same computer\footnote{Macbook Pro 2,6 GHz Core 2 Duo
4GB RAM. Mac OS 10.5.7}, we achieve a execution time that it's about twenty
times faster.

\newpage
\subsection{Fibonacci}
\begin{figure}[htp]
  \begin{center}
    \begin{tikzpicture}[node distance   = 4 cm]
      \GraphInit[vstyle=Normal]
      \tikzset{LabelStyle/.style =   {draw}}
      \Vertex{FibonacciInt}
      \EA(FibonacciInt){Stop}
      \EA(Stop){Printer}
      \tikzstyle{EdgeStyle}=[->]
      \Edge[label=c1](FibonacciInt)(Stop)
      \Edge[label=c2](Stop)(Printer)
    \end{tikzpicture}
% \begin{center}
%   \includegraphics[width=14.0cm,keepaspectratio=true]{figures/fibonacci.pdf}
% \end{center}
% \caption{Representation of the CSP network.}
% \label{figurefibonacci}
  \end{center}
  \caption{Pretty nice ...}
\end{figure}

This test, once we have implemented all the {\it Legoland}\cite{vintercsp}
components, was a very easy and straight forward task. Even though that it
looks like this network doesn't do much it was very useful to discover that
our first implementation didn't work correctly.

Another thing was that we implemented our {\it Legoland} components as
recursive function, but not tail-recursive, after running this application
for a lot of iteration, about 75.000, we began to get messages of stack
overflow. Once we rewrote the components from recursive to using {\it while true
do} we was able to run more than a 1.000.000 iterations, We supouse we can
run even more but we didn't test it out.

A description on how this simple network works can be seen in Figure\ref{?}
where we use the {\it Legoland fibonacciInt} component running in parallel
with a {\it stop} component which, ensures that the network shuts down correctly
after the number of iterations given as the first parameter, and a {\it printer}
component which prints out to the screen the Fibonacci numbers.


\subsection{Webproxy}

TODO: A picture of network (made with tkiz) goes here !!!

\subsection{Channel permisions and alternation}

One of the features this API has is that you have the possibility to set 
read/write/poision permissions on the channels. With this test we will
demostrate where this is useful. What we do is that we have to components
that just counts integers. When the second counter reaches $20$ we want
to poison the whole network. But we have sat the first count to only count
to 10 and it will shutdown the hole network through the {\it stop}
component from the {\it Legoland} library. But this is a problem, we don't
want the first counter to shut down the network so we add {\it write\_only}
to counter components output channel. This will result in a compiler error
because the {\it stop} component once it's poisoned it propagates the poison
to all the other channels, but we have just defined our output channel to
only allow write.

We now make a {\it custom\_stop} component which only propagates poison to
the input channel. We are now able to compile and run the application knowing
that our first counter will never shutdown our network through poison.

Even though we don't allow to propagate poison whenever the second counter
reaches it's number and poison the printer component. Then when the first
counter will write over the {\it custom\_stop} component, it will actually
raise a {\it PoisonException} which will be progated back to the counter
ensuring that all of the processes terminate and hereby ensuring that network
shuts down correctly.

Besides the channel permision we also added a small {\it guard} test which read
from the two counters whenever one of them is ready. By setting the first
counter to only send 5 numbers, we can actually check that when setting the
second counter to the double we can see that the {\it custom\_printer} component
will see if any of the to {\it read\_guards} are ready to read from the counters
and because one stop early it will keep reading from the second.


\section{Conclusion}
\label{conclusion}

If we compare how Brian Vinter teaches CSP\cite{vintercsp}:
\begin{center}
\begin{verbatim}
PairsInt (in, out) = Delta2Int (in, a, c) || 
                     TailInt (a, b) || 
                     PlusInt (b, c, out) 
\end{verbatim}
\end{center}

versus how we implement the simple network:

\begin{verbatim}
let pairsInt i o () =
  let a = Csp.channel () in
  let b = Csp.channel () in
  let c = Csp.channel () in
    Csp.parallel [
      delta2int i a c;
      tailint a b;
      plusint b c o;
    ]
\end{verbatim}

We can see that there is almost no difference beside the {\it parallel operator}
and definition of the channel variables.

% ----------------------------------------------------------------------
% Bibliography
% ----------------------------------------------------------------------
\newpage
\begin{thebibliography}{99}

\bibitem[Hoare 04]{hoare}
:\\
Communicating Sequential Processes\\
C. A. R. Hoare\\
Prentice Hall International; (June 24, 2004)\\
ISBN-10: 0-13-153271-5\\
ISBN-13: 978-0-13-153271-7\\
http://www.usingcsp.com/cspbook.pdf


\bibitem[Vinter, PyCSP]{vinterpycsp}
:\\
PyCSP. The beginning of a CSP library for Python\\
Brian Vinter\\
Department of Computer Science. University of Copenhagen\\
http://isis.ku.dk/kurser/blob.aspx?feltid=224718\\
Last visited: $20^{th}$ july 2009

\bibitem[Vinter, CSP]{vintercsp}
:\\
Threading\\
Brian Vinter\\
Department of Computer Science. University of Copenhagen\\
http://isis.ku.dk/kurser/blob.aspx?feltid=224185\\
Last visited: $20^{th}$ july 2009



\end{thebibliography}
% ----------------------------------------------------------------------

\appendix
\newpage
\section{Appendix: Source code}
\label{appendixSrc}

\scriptsize
\subsection{API}
\label{appendixAPI}
\includecode{csp.mli}{../source/csp.mli}
\includecode{csp.ml}{../source/csp.ml}
\subsection{A CSP Utility Library}
\includecode{cspu.ml}{../source/cspu.ml}
\subsection{A CSP Component Library (Legoland)}
\includecode{legoland.ml}{../source/legoland.ml}


\newpage
\section{Appendix: Documentation}
\label{appendixDoc}
\begin{center}
  \includepdf[pages=-]{../docs/csp.pdf}
\end{center}


\newpage
\section{Appendix: Test}
\label{appendixTest}
\subsection{Performance}

\subsubsection{Maxthreads}
\includecode{maxthreads.ml}{../test/maxthreads.ml}
\runtest{ocamlc -vmthread unix.cma threads.cma maxthreads.ml -o maxthreads \&\&
  ./maxthreads}
\includeoutput{userMaxThreads.txt}{test/userMaxThreads.txt}
\runtest{ocamlc -thread unix.cma threads.cma maxthreads.ml -o maxthreads \&\&
  ./maxthreads}
\includeoutput{sysMaxThreads.txt}{test/sysMaxThreads.txt}

\newpage
\subsubsection{Nonblocking}
\includecode{nonblocking.ml}{../test/nonblocking.ml}
\runtest{ocamlc -vmthread threads.cma unix.cma nonblocking.ml -o nonblocking
  \&\& ./nonblocking}
\includeoutput{nonblocking.txt}{test/nonblocking.txt}

\subsubsection{Commstime}
\includecode{commstime.ml}{../test/commstime.ml}
\runtest{./buildCommstime.sh \&\& ./commstime}
\includeoutput{ocamlcsp\_commstime.txt}{test/ocamlcsp_commstime.txt}
\includeoutput{pycsp\_commstime.txt}{test/pycsp_commstime.txt}

\subsection{Fibonacci}
\includecode{fibCSP.ml}{../test/fibCSP.ml}
\runtest{./buildFibCSP.sh \&\& ./buildFibCSP}
\newpage
\includeoutput{fibonacci.txt}{test/fibonacci.txt}

\newpage
\subsection{Webproxy}
\includecode{proxyCSP.ml}{../test/proxyCSP.ml}
\includecode{server.rb}{../test/web/server.rb}
Start two sequential webservers (ruby):

\runtest{ruby server.rb 4040 0.1 \&}

\runtest{ruby server.rb 4041 0.3 \&}


Start the webproxy:

\runtest{./buildProxy.sh \&\& ./proxyCSP \&}


Add the webproxy to the terminal session:

\runtest{export http\_proxy=http://localhost:8080}


Retrieve the file foo.mp3 from the first webserver:

\runtest{wget http://localhost:4040/foo.mp3}
\includeoutput{proxy\_get\_file\_first\_time.txt}{
  test/proxy_get_file_first_time.txt}


Retrieve the file foo.mp3 again from the first webserver (cache):

\runtest{wget http://localhost:4040/foo.mp3}

\includeoutput{proxy\_get\_file\_second\_time.txt}{
  test/proxy_get_file_second_time.txt}


Retrieve concurrent the files bar.mp3 and foo.mp3 from the two webservers:

\includeoutput{proxy\_same\_time\_bar.txt}{
  test/proxy_same_time_bar.txt}
\includeoutput{proxy\_same\_time\_foo.txt}{
  test/proxy_same_time_foo.txt}

\newpage
\subsection{Channel permisions and alternation}
\includecode{permission.ml}{../test/permission.ml}
\runtest{./buildPermission.sh \&\& ./buildPermission}
\includeoutput{alternation\_permision\_error.txt}{
  test/alternation_permision_error.txt}
\includeoutput{alternation\_permision\_one\_guard.txt}{
  test/alternation_permision_one_guard.txt}
\includeoutput{alternation\_permision\_poison.txt}{
  test/alternation_permision_poison.txt}


\end{document}
