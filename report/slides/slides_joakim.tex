\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[danish, english]{babel}
\usepackage{beamerthemesplit}
\usepackage{color}

% Math support
\usepackage{amssymb}
\usepackage{amsmath}

\title[OCamlCSP]{
  OCamlCSP - A concurrency library for OCaml
}
\author[Joakim A.]{
  Joakim Ahnfelt-Rønne
}
\institute[DIKU]{
  Datalogisk Institut \\ Københavns Universitet
}
\date{28. august 2009}

\definecolor{kugreen}{RGB}{50,93,61}
\definecolor{kugreenlys}{RGB}{132,158,139}
\definecolor{kugreenlyslys}{RGB}{173,190,177}
\definecolor{kugreenlyslyslys}{RGB}{214,223,216}
\setbeamercovered{transparent}
\mode<presentation> {
 \usetheme{PaloAlto}
 \usecolortheme[named=kugreen]{structure}
 \useinnertheme{circles}
 \usefonttheme[onlymath]{serif}
 \setbeamercovered{transparent}
 \setbeamertemplate{blocks}[rounded][shadow=true]
}
\logo{\includegraphics[width=1cm]{figures/B_NAT_cmyk.pdf}}

\begin{document}

\frame{
 \titlepage
}

\section[Hvorfor?]{}
\frame{
  \frametitle{Hvorfor?}
  \begin{itemize}
    \item CSP som model for samtidighed:
    \begin{itemize}
      \item Hierakisk processmodel
      \item Synkron beskedudveksling
      \item Passiv venten på flere kanaler samtidig
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP (C++) 
      \item JCSP (Java)
      \item PyCSP (Python)
      \item CHP (Haskell)
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP $\leftarrow$ imperativt sprog, objektorienteret design
      \item JCSP $\leftarrow$ ditto
      \item PyCSP $\leftarrow$ ditto
      \item CHP $\leftarrow$ rent funktionelt sprog, monadisk design
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP $\leftarrow$ imperativt sprog, objektorienteret design
      \item JCSP $\leftarrow$ ditto
      \item PyCSP $\leftarrow$ ditto
      \item CHP $\leftarrow$ rent funktionelt sprog, monadisk design
      \item \textbf{OCamlCSP} 
      \begin{itemize}
        \item Urent funktionelt sprog (sideeffekter)
        \item Traditionelt ML-design (moduler)
        \item I stil med eksisterende OCaml-biblioteker
      \end{itemize}
    \end{itemize}
  \end{itemize}
}


\section[Målsætning]{}
\frame{
  \frametitle{Målsætning}
  \begin{itemize}
    \item Mål
      \begin{itemize}
      \item At bruge processmodellen og kanalerne fra CSP som fundament for et samtidighedsbibliotek
      \item At levere et lille interface der passer ind i stilen for OCamls eksisterende biblioteker
      \end{itemize}
  \end{itemize}
}



\section[Design]{}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item 
      \begin{itemize}
        \item ??? Et argument for den hierakiske processmodel
      \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item 
      \begin{itemize}
        \item ??? hvorfor kanaler skal være data
        \item ??? hvorfor kanaler skal være any2any
        \item ??? hvorfor vi skal have select
        \item ??? hvorfor vi ikke skal have priSelect
        \item ??? hvorfor vi skal have randomSelect
        \item ??? hvorfor vi skal have read og write guards
        \item ??? Argumenter hvorfor vi skal have guarded processes
        \item ??? beskrivelse af hvorfor select er lidt som external choice og lidt som general choice
      \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item En finurlig konsekvens
      \begin{itemize}
      \item Alle typer data kan sendes over kanaler
      \item Kanaler er data
      \item Ergo kan kanaler sendes over kanaler, som i $\pi$-calculus
      \end{itemize}
  \end{itemize}
}


\section[Eksempler]{}
\frame{
  \frametitle{Eksempler}
  \begin{itemize}
    \item ??? Eksempel fra Fib
    \item ??? Eksempel fra Proxy
    \item ??? Hvad er biblioteket godt til?
  \end{itemize}
}


\section[Kode]{}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
  \item Alternation
    \begin{itemize}
    \item Select er som de andre bibliotekers priSelect
    \item Bortset fra at vi permuterer listen tilfældigt først
    \item Først tjekkes det om der er nogen der venter på en af kanalerne
    \item Derefter stiller den sig i kø på hver af kanalerne
    \item Ved kommunikation fjerner den sig fra hver kanals kø
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
  \item Kanaler
    \begin{itemize}
    \item Kanalers state tager udgang i en finite state machine
    \item Men udvider den til et arbitrært antal af ventende processer
    \item Og understøtter poison
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item ??? Hastighed
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item ??? Mangel på halekald i parallel?
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item OCaml har ingen garbage collector der kan håndtere samtidighed
    \item Derfor kan et bibliotek bygget på OCamls trådbibliotek ikke understøtte samtidighed på hardware-niveau
    \item Men det kunne måske gøres via inter process communication
  \end{itemize}
}


\section[Spørgsmål]{}
\frame{
  \frametitle{Spørgsmål}
  \begin{itemize}
    \item Slut på præsentationen
  \end{itemize}
}

\end{document}
