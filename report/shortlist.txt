abstract:
can't offer -> does not offer

struktur:
giv evt. references et toc menupunkt.
byt om på appendix A og B

giv reference til appenix apidoc for at fremhæve det,
eller giv det dets eget afsnit.

sammenlign med Communicating Haskell Processes, som er
CSP-agtigt til haskell med monader. argumenter for at det
modellen ikke passer i ocaml hvis det er tilfældet.

se på concurrent ML.

(poison) in introduktion skal omformuleres.

Web proxy i to ord.

Det er ikke godt med referencer i introduktionen, det er
åbentlyst at det vil blive uddybet senere (cites er ok).

API design:
minimalism in intro: we moved everything else into the
der skal i introduktionen

sig klarerer hvorfor vi bruger funktioner (to suspend the
evaluation of the processes in a CBV language)

giv et argument for arbitrary exception (cannot depend on
order, less restrictions on the implementation)-.

forklar hvad vi mener med flat (intet tilhørsforhold) og 
hirakial model (med subprocesses).

sæt funktionsnavne i \emph

skriv mangel på parallelism lige ved parallel
skriv shared state lige ved parallel og nævn at det også
kan deles ved scope.

since we're in a functional language it is even less
natural to have shared mutable state. Ikke hæve 
external choice er ikke en operator! det er et sæt med
paranteser omkring. Alle processer i external choice skal
eksponere deres "guard"! nævn at vores er tættere på CSP
external choice end de andre. 
pri alt i occam kode (el. lign)
skip guards etc skal være med småt.

skriv at man kan lave både read og write guards på den
samme kanal i samme select, men at den ikke kommunikerer
med sig selv. 
vi er lidt mere over i general choice da vi kan
sige skriv a og skriv b til den samme kanal i en select.
på hvilken måde er vi ext og gen choice? fremhæv at det
er lidt forskelligt fra csp fordi vi har any2any.
i csp er kanaler altid mellem to forskellige processer.

du kan faktisk godt lave polling med shuffle select og
skip guards (well en kanal der altid har noget at læse),
det kan tage bare længere tid end ved priSelect.

vis det med det filtrering med boolske udtryk, put det
f.eks. i Cspu, evt sum boolean guards. vis evt. eksemplet 
med en buffer guard (nogle gange klar til at læse nogle
gange til at skrive).

concurrent = samtidighedsmodellen
parallelism = samtidighed på hardwareniveau
ret parallelism næsten alle steder vi bruger det

implementation
skriv at vi konceptuelt gør det samme som CSP med read 
og write, idet prefixing er external choices med et valg.

ocamltest
maxthreads mangler en konklusion (hvor mange tråde kan
man så få?)
nonblocking forklar referencen "brug systhreads", og fortæl
om konflikten mellem den og det vi siger, og hvorfor det
virker med user threads (hvis det gør!). skriv hvornår 
referencen er 
referencer til testkoden før detaljer i testafsnittene.

webproxy
- hvad skal den kunne
- hvorfor er det bedre at bruge csp end mutexes etc.?
- kig evt. på den web proxy der er i "use sythreads".

referer til koden fra implementation?

i ocamldoc, skriv at det er example ved hver eksempel,
ellers virker det mærkeligt.

aflever elektronisk i studieadm cc til andrzej + fysisk
kopi. vedhæft koden som zip

