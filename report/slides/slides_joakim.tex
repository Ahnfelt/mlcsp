\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[danish, english]{babel}
\usepackage{beamerthemesplit}
\usepackage{color}

% Math support
\usepackage{amssymb}
\usepackage{amsmath}

\title[OCamlCSP]{
  OCamlCSP - A concurrency library for OCaml
}
\author[Joakim A.]{
  Joakim Ahnfelt-Rønne
}
\institute[DIKU]{
  Datalogisk Institut \\ Københavns Universitet
}
\date{28. august 2009}

\definecolor{kugreen}{RGB}{50,93,61}
\definecolor{kugreenlys}{RGB}{132,158,139}
\definecolor{kugreenlyslys}{RGB}{173,190,177}
\definecolor{kugreenlyslyslys}{RGB}{214,223,216}
\setbeamercovered{transparent}
\mode<presentation> {
 \usetheme{PaloAlto}
 \usecolortheme[named=kugreen]{structure}
 \useinnertheme{circles}
 \usefonttheme[onlymath]{serif}
 \setbeamercovered{transparent}
 \setbeamertemplate{blocks}[rounded][shadow=true]
}
\logo{\includegraphics[width=1cm]{figures/B_NAT_cmyk.pdf}}

\begin{document}

\frame{
 \titlepage
}

\section[Hvorfor?]{}
\frame{
  \frametitle{Hvorfor?}
  \begin{itemize}
    \item CSP som model for samtidighed:
    \begin{itemize}
      \item Hierakisk processmodel
      \item Synkron beskedudveksling
      \item Passiv venten på flere kanaler samtidig
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP (C++) 
      \item JCSP (Java)
      \item PyCSP (Python)
      \item CHP (Haskell)
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP $\leftarrow$ imperativt sprog, objektorienteret design
      \item JCSP $\leftarrow$ ditto
      \item PyCSP $\leftarrow$ ditto
      \item CHP $\leftarrow$ rent funktionelt sprog, monadisk design
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Eksistensberettigelse}
  \begin{itemize}
    \item Flere biblioteker eksisterer allerede:
    \begin{itemize}
      \item C++CSP $\leftarrow$ imperativt sprog, objektorienteret design
      \item JCSP $\leftarrow$ ditto
      \item PyCSP $\leftarrow$ ditto
      \item CHP $\leftarrow$ rent funktionelt sprog, monadisk design
      \item \textbf{OCamlCSP} 
      \begin{itemize}
        \item Urent funktionelt sprog (sideeffekter)
        \item Traditionelt ML-design (moduler)
        \item I stil med eksisterende OCaml-biblioteker
      \end{itemize}
    \end{itemize}
  \end{itemize}
}


\section[Målsætning]{}
\frame{
  \frametitle{Målsætning}
  \begin{itemize}
    \item Mål
      \begin{itemize}
      \item At bruge processmodellen og kanalerne fra CSP som fundament for et samtidighedsbibliotek
      \item At levere et lille interface der passer ind i stilen for OCamls eksisterende biblioteker
      \end{itemize}
  \end{itemize}
}



\section[Design]{}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item 
      \begin{itemize}
        \item ??? Et argument for den hierakiske processmodel
      \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item 
      \begin{itemize}
        \item ??? hvorfor kanaler skal være data
        \item ??? hvorfor kanaler skal være any2any
        \item ??? hvorfor vi skal have select
        \item ??? hvorfor vi ikke skal have priSelect
        \item ??? hvorfor vi skal have randomSelect
        \item ??? hvorfor vi skal have read og write guards
        \item ??? Argumenter hvorfor vi skal have guarded processes
        \item ??? beskrivelse af hvorfor select er lidt som external choice og lidt som general choice
      \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Design}
  \begin{itemize}
    \item En finurlig konsekvens
      \begin{itemize}
      \item Alle typer data kan sendes over kanaler
      \item Kanaler er data
      \item Ergo kan kanaler sendes over kanaler, som i $\pi$-calculus
      \end{itemize}
  \end{itemize}
}


\section[Eksempler]{}
\begin{frame}[fragile]
  \frametitle{Eksempel: Fibonacci (parallel)}
\begin{verbatim}
FibonacciInt (out) =              (* pseudo-code *)
    PrefixInt (1, c4, c1)   ||
    PrefixInt (0, c1, c2)   ||
    Delta2Int (c2, out, c3) ||
    PairsInt (c3, c4)
\end{verbatim}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Eksempel: Fibonacci (parallel)}
{\tiny
\begin{verbatim}
FibonacciInt (out) =                                               (* pseudo-code *)
    PrefixInt (1, c4, c1)   ||
    PrefixInt (0, c1, c2)   ||
    Delta2Int (c2, out, c3) ||
    PairsInt (c3, c4)
\end{verbatim}
}
\begin{verbatim}
let fibonacciInt out () =         (* actual code *)
  let c1 = Csp.new_channel () in
  let c2 = Csp.new_channel () in
  let c3 = Csp.new_channel () in
  let c4 = Csp.new_channel () in
    Csp.parallel [
      prefixInt 1 c4 c1;
      prefixInt 0 c1 c2;
      delta2Int c2 out c3;
      pairsInt c3 c4
    ]
\end{verbatim}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Eksempel: Proxy (select)}
\begin{verbatim}
let cache i o d () =
    let rec loop t =
        Csp.select [
            Csp.read_guard i (fun u ->
                (try let n = Table.find u t in
                    Csp.write o (Some n)
                with Not_found -> Csp.write o None);
                loop t
            );
            Csp.read_guard d (fun (u, n) ->
                loop (Table.add u n t)
            );
        ]
    in loop Table.empty
\end{verbatim}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Anvendelse}
  \begin{itemize}
    \item Anvendelse
    \begin{itemize}
      \item Applikationer der indbyder til en samtidig struktur
        \begin{itemize}
          \item Grafiske brugergrænseflader (event-handling)
          \item Servere (en process til hvert request)
        \end{itemize}
      \item I/O-bundene programmer
    \end{itemize}
  \end{itemize}
\end{frame}


\section[Kode]{}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
  \item Alternation
    \begin{itemize}
    \item Select er som de andre bibliotekers priSelect
    \item Bortset fra at vi permuterer listen tilfældigt først
    \item Først tjekkes det om der er nogen der venter på en af kanalerne
    \item Derefter stiller den sig i kø på hver af kanalerne
    \item Ved kommunikation fjerner den sig fra hver kanals kø
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
  \item Kanaler
    \begin{itemize}
    \item Kanalers state tager udgang i en finite state machine
    \item Men udvider den til et arbitrært antal af ventende processer
    \item Og understøtter poison
    \end{itemize}
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item ??? Hastighed
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item ??? Mangel på halekald i parallel?
  \end{itemize}
}
\frame{
  \frametitle{Implementation}
  \begin{itemize}
    \item OCaml har ingen garbage collector der kan håndtere samtidighed
    \item Derfor kan et bibliotek bygget på OCamls trådbibliotek ikke understøtte samtidighed på hardware-niveau
    \item Er det overhovedet interessant at basere hardware-samtidighed på en shared-memory model?
    \item Måske kunne man lave en løsning med kommunikation over TCP eller UDP - måske er det ikke praktisk
          på grund af synkroniseringen.
  \end{itemize}
}


\section[Spørgsmål]{}
\frame{
  \frametitle{Spørgsmål}
  \begin{itemize}
    \item Slut på præsentationen
  \end{itemize}
}

\end{document}
